#include <stdio.h>
#include <stdlib.h>
#include <allegro.h>
#include <winalleg.h>
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#include "objects.h"
#include "monster.h"
#include "champions.h"
#include "global_data.h"
#include "uproto.h"
#include "compile.h"
#include "arch.h"
#include "editor_hwndptr.h"
#include "editor_gui.h"
#include "editor_menu.h"
#include "editor_shared.h"

extern HWND sys_hwnd;

extern lua_State *LUA;
extern struct editor_global edg;
extern struct global_data gd;
extern int Gmparty_flags;

extern struct dungeon_level *dun;
extern struct inst *oinst[NUM_INST];

void inst_out(FILE *ef, unsigned int inst, struct inst *p_inst, int rc) {
    char inst_write_msg[80];
    struct obj_arch *p_arch;

    if (!rc)
        v_onstack("inst_out");

    if (rc > 20) {
        MessageBox(sys_hwnd, "Recursion Terminated",
            "Error", MB_ICONEXCLAMATION);
        return;
    }

    p_arch = Arch(p_inst->arch);
    
    sprintf(inst_write_msg, "store_inst(%ld, %s, %ld, %ld, %ld, %ld, %ld)",
        inst, p_arch->luaname, p_inst->level, p_inst->x, p_inst->y,
        p_inst->tile, p_inst->inside_n);
    v_onstack(inst_write_msg);

    fprintf(ef, "dsb_spawn(%ld, \"%s\", ", inst, p_arch->luaname);
    
    if (p_inst->level <= LOC_LIMBO)
        fprintf(ef, "LIMBO, ");
    else if (p_inst->level == LOC_CHARACTER)
        fprintf(ef, "CHARACTER, ");
    else if (p_inst->level == LOC_IN_OBJ)
        fprintf(ef, "IN_OBJ, ");
    else
        fprintf(ef, "%ld%s", p_inst->level, ", ");

    if (p_inst->level == LOC_CHARACTER) {
        int cid = p_inst->x - 1;
        fprintf(ef, "%s", edg.c_ext[cid].desg);
    } else {
        fprintf(ef, "%ld", p_inst->x);
    }

    fprintf(ef, ", %ld, %ld)\n", p_inst->y, p_inst->tile);
    if (p_inst->gfxflags & OF_INACTIVE)
        fprintf(ef, "dsb_disable(%ld)\n", inst);
    if (p_inst->gfxflags & ~(OF_INACTIVE))
        fprintf(ef, "dsb_set_gfxflag(%ld, %lu)\n", inst, p_inst->gfxflags & ~(OF_INACTIVE)); 
    if (p_inst->ai && p_inst->ai->d_hp)
        fprintf(ef, "mon_hp(%ld, %ld)\n", inst, p_inst->ai->hp);
    if (p_inst->facedir != 0)
        fprintf(ef, "dsb_set_facedir(%ld, %ld)\n", inst, p_inst->facedir);
    if (p_inst->charge != 0)
        fprintf(ef, "dsb_set_charge(%ld, %ld)\n", inst, p_inst->charge);
    if (p_inst->crop != 0)
        fprintf(ef, "dsb_set_crop(%ld, %ld)\n", inst, p_inst->crop);
    if (p_inst->frame != 0)
        fprintf(ef, "dsb_set_animtimer(%ld, %lu)\n", inst, p_inst->frame);

    if (p_inst->inside_n) {
        int ic;
        for (ic=0;ic<p_inst->inside_n;++ic) {
            unsigned int ii = p_inst->inside[ic];
            if (ii) {
                struct inst *p_i_inst = oinst[ii];
                inst_out(ef, ii, p_i_inst, rc+1);
            }
        }
    }

    v_upstack();
    if (!rc) {
        v_upstack();
    }
}

void esb_write_serialized_xvt(FILE *ef, int id) {
    const char *serialized_output;
    
    onstack("esb_write_serialized_xvt");
    
    // dump anything that's not a table
    // (mostly nils, but also eliminates any screwing around)
    if (!lua_istable(LUA, -1)) {
        VOIDRETURN();
    }
     
    // don't bother to store a completely empty element 
    lua_pushnil(LUA);
    if (lua_next(LUA, -2) == 0) {
        VOIDRETURN();
    }
    lua_pop(LUA, 2); // pop the key and value that lua_next pushed
    
    lua_getglobal(LUA, "__serialize");
    lua_pushstring(LUA, "\n");
    lua_pushstring(LUA, "");
    lua_pushvalue(LUA, -4);
    if (lua_pcall(LUA, 3, 1, 0) != 0) {
        lua_function_error("saving_serializer", lua_tostring(LUA, -1));
        VOIDRETURN();
    }
    
    v_onstack("serializer_filewriter");
    serialized_output = lua_tostring(LUA, -1);
    fprintf(ef, "[%ld] = %s%s\n", id, serialized_output, ",");
    lua_pop(LUA, 1);
    lstacktop();
    v_upstack();

    VOIDRETURN();
}

void editor_export_dungeon(const char *fname) {
    int last_alloc = 0;
    char tdbuffer[256];
    FILE *ef;
    int i;

    onstack("editor_export_dungeon");
    
    sprintf(tdbuffer, "%s%s", fname, ".bak");
    CopyFile(fname, tdbuffer, 1);
    memset(tdbuffer, 0, sizeof(tdbuffer));
    
    ef = fopen(fname, "w");
    if (ef == NULL) {
        MessageBox(NULL, "Write Error", "Error", MB_ICONSTOP);
        VOIDRETURN();
    }
    
    fprintf(ef, "---DSB ESB---\n--[[ Autogenerated by ESB.\n");
    fprintf(ef, " Trying to edit this file by hand may not give you\n");
    fprintf(ef, " particularly good results.\n]]\n\n");

    luastacksize(6);
    lua_getglobal(LUA, "_ESBWALLSET_NAMES");
    for(i=0;i<gd.dungeon_levels;++i) {
        const char *ws_str;
        int yy;
        
        fprintf(ef, "dsb_text2map(%d, %d, %d, %d, %d, {\n",
            i, dun[i].xsiz, dun[i].ysiz,
            dun[i].lightlevel, dun[i].xp_multiplier);
            
        for(yy=0;yy<dun[i].ysiz;++yy) {
            const char *ws_str;
            int xx;
            
            fprintf(ef, "\"");
            
            for(xx=0;xx<dun[i].xsiz;++xx) {
                if (dun[i].t[yy][xx].w & 1)
                    fprintf(ef, "0");
                else
                    fprintf(ef, "1");
            }
            
            if (yy == dun[i].ysiz - 1)
                fprintf(ef, "\"} )\n");
            else
                fprintf(ef, "\",\n");
        }
        
        if (dun[i].level_flags != 0) {
            fprintf(ef, "dsb_level_flags(%d, %u)\n", i, dun[i].level_flags);            
        }
        
        if (dun[i].tint != 0 || dun[i].tint_intensity != DSB_DEFAULT_TINT_INTENSITY) {
            int t = dun[i].tint;
            if (dun[i].tint_intensity != DSB_DEFAULT_TINT_INTENSITY) {
                fprintf(ef, "dsb_level_tint(%d, { %d, %d, %d }, %d)\n",
                    i, getr(t), getg(t), getb(t), dun[i].tint_intensity);
            } else {
                fprintf(ef, "dsb_level_tint(%d, { %d, %d, %d })\n",
                    i, getr(t), getg(t), getb(t));
            }
        }
                
        lua_pushinteger(LUA, i);
        lua_gettable(LUA, -2);
        if (!lua_isstring(LUA, -1)) {
            ws_str = "default";
        } else
            ws_str = lua_tostring(LUA, -1);
        fprintf(ef, "dsb_level_wallset(%d, %s%s)\n", i, "wallset.", ws_str);
        lua_pop(LUA, 1);
    }
    lua_pop(LUA, 1);
    
    lua_getglobal(LUA, "_ESBLEVELUSE_WALLSETS");
    for(i=0;i<gd.dungeon_levels;++i) {
        int yy;
        for(yy=0;yy<dun[i].ysiz;++yy) {
            int xx;
            for(xx=0;xx<dun[i].xsiz;++xx) {
                int t;
                for(t=4;t>=0;--t) {
                    lua_pushinteger(LUA, wscomp(i, xx, yy, t));
                    lua_gettable(LUA, -2);
                    if (lua_isstring(LUA, -1)) {
                        const char *ws_str = lua_tostring(LUA, -1);
                        fprintf(ef, "dsb_alt_wallset(wallset.%s, %ld, %ld, %ld, %ld)\n",
                            ws_str, i, xx, yy, t);
                    }
                    lua_pop(LUA, 1);
                }
            }
        }
    }
    lua_pop(LUA, 1);
    
    for(i=0;i<gd.num_champs;++i) {
        struct champion *me = &(gd.champs[i]);
        if (edg.c_ext[i].desg) {
            int j;
            
            fprintf(ef, "dsb_add_champion(%lu, \"%s\", \"%s\", \"%s\", \"%s\"",
                i+1, edg.c_ext[i].desg, me->port_name, me->name,
                me->lastname);

            for(j=0;j<MAX_BARS;++j)
                fprintf(ef, ", %lu", me->maxbar[j]);
                
            for(j=0;j<MAX_STATS;++j)
                fprintf(ef, ", %lu", me->maxstat[j]);
                
            for(j=0;j<gd.max_class;++j) {
                int sub;
                fprintf(ef, ", {%lu", determine_mastery(1, i, j, 0, 0));
                for(sub=0;sub<gd.max_subsk[j];sub++) {
                    fprintf(ef, ",%lu", determine_mastery(1, i, j, sub+1, 0));
                }
                fprintf(ef, "}");
            }

            fprintf(ef, ")\n");
        
            if (me->method_name && strcmp(me->method_name, "unarmed_methods")) {
                fprintf(ef, "dsb_replace_methods(%lu, \"%s\")\n", i+1, me->method_name);
            }
        }
    }

    // ch_exvars right after champions
    // in case their inventory does things to them
    luastacksize(12);
    lua_getglobal(LUA, "ch_exvar");
    fprintf(ef, "ch_exvar = {\n");
    for (i=0;i<gd.num_champs;++i) {
        lua_pushinteger(LUA, i+1);
        lua_gettable(LUA, -2);
        esb_write_serialized_xvt(ef, i+1);
        lua_pop(LUA, 1);
    } 
    lua_pop(LUA, 1); 
    fprintf(ef, "}\n");
    
    for(i=0;i<NUM_INST;++i) {   
        if (oinst[i]) last_alloc = i;
    }
            
    fprintf(ef,"dsb_spawnburst_begin(%d)\n", last_alloc); 
    
    for(i=0;i<NUM_INST;++i) {
        struct inst *p_inst = oinst[i];      
        if (p_inst) {
            if (p_inst->level <= LOC_CHARACTER) {
                if ((edg.editor_flags & EEF_NOLIMBOSAVE) &&
                    p_inst->level <= LOC_LIMBO &&
                    p_inst->level != LOC_PARCONSPC) 
                {
                    // this inst isn't being saved
                    // so if it has an exvar let's nuke it
                    lc_parm_int("__void_exvar", 1, i);
                    continue;
                }
                inst_out(ef, i, p_inst, 0);
            }
        }
    }
    for(i=0;i<gd.num_champs;++i) {
        struct champion *me = &(gd.champs[i]);
        if (edg.c_ext[i].desg && me->exinst) {
            fprintf(ef, "dsb_set_exviewinst(%ld, %ld)\n", i+1, me->exinst);
        }
    }
    
    for(i=0;i<gd.dungeon_levels;++i) {
        int yy;
        struct dungeon_level *dd = &(dun[i]);
        for(yy=0;yy<dun[i].ysiz;++yy) {
            int xx;
            for(xx=0;xx<dun[i].xsiz;++xx) {
                int d;
                for(d=0;d<=4;d++) {
                    struct inst_loc *dt = dd->t[yy][xx].il[d];
                    while (dt != NULL) {
                        struct inst *p_inst = oinst[dt->i];
                        inst_out(ef, dt->i, p_inst, 0);
                        dt = dt->n;
                    }
                }   
            }
        }
    }  
    
    // dump the exvars
    luastacksize(12);
    lua_getglobal(LUA, "exvar");
    fprintf(ef, "exvar = {\n");
    for (i=0;i<NUM_INST;++i) {
        if (oinst[i]) {
            lua_pushinteger(LUA, i);
            lua_gettable(LUA, -2);
            esb_write_serialized_xvt(ef, i);
            lua_pop(LUA, 1);
        }
    } 
    lua_pop(LUA, 1);
    fprintf(ef, "}\n");
        
    fprintf(ef,"dsb_spawnburst_end()\n");
    
    if (gd.gameplay_flags) {
        fprintf(ef, "dsb_set_gameflag(%lu)\n", gd.gameplay_flags);
    }
    
    if (Gmparty_flags) {
        fprintf(ef, "dsb_set_mpartyflag(%lu)\n", Gmparty_flags);
    } 
    
    fprintf(ef, "EDITOR_FLAGS = %lu\n", edg.editor_flags);
    
    for(i=0;i<4;i++) {
        if (gd.party[i]) {
            fprintf(ef, "dsb_champion_toparty(%d, %d)\n",
                i, gd.party[i]);
        }
    }
    
    fprintf(ef, "dsb_party_place(%d, %d, %d, %d)\n",
        gd.p_lev[0], gd.p_x[0], gd.p_y[0], gd.p_face[0]);

    fprintf(ef, "\n");
    fclose(ef);
    
    sprintf(tdbuffer, "%s saved.", fname);
    SetWindowText(edg.infobar, tdbuffer);
    
    VOIDRETURN();
}
